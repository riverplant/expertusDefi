Stream多线程
*******************************************************************
//获得CPU核数
System.out.println(Runtime.getRuntime().availableProcessors());
*******************************************************************
    private static long LongStreamParalle(long limit) {//使用并行速度是普通的2倍以上
		return LongStream.rangeClosed(1, limit).parallel().sum();
	}
	
	/**
	 * 非Stream的写法
	 * 
	 * @param limit
	 * @return
	 */
	private static long normalAdd(long limit) {
		long result = 0L;
		for (long i = 0; i < limit; i++) {
			result += i;
		}
		return result;
	}
	//设置系统并行的个数!!!!尽量不要去改变
	System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism","20")
	并行的效果:
	ArrayList        Excellent
	LinkedList       poor
	IntStream.range  Excellent
	Stream.iterate   Poor
	HashSet          Good
	TreeSet          Good
***************************ForkJoin框架！！！！分而治之类似于MapperReduce***********************************
1.ForkJoinPool

2.RecursiveTask:有返回值
public abstract class RecursiveTask<V> extends ForkJoinTask<V> 

3.RecursiveAction

***************************ForkJoin框架！！！！***********************************
**************************Spliterator**********************************************
 boolean tryAdvance(Consumer<? super T> action);
 /**
 *循环执行forEachRemaining直到tryAdvance(action)为false
 */
  default void forEachRemaining(Consumer<? super T> action) {
        do { } while (tryAdvance(action));
    }
  //通过递归实现分而治之,将数组分开的功能 
  Spliterator<T> trySplit();
  
// int characteristics()特征值
 default long getExactSizeIfKnown() {
        return (characteristics() & SIZED) == 0 ? -1L : estimateSize();
    }
**************重写一个MySpliterator********************
class MySpliteratorText {
	private final String[] data;
	private String regix;
	public String getRegix() {
		return regix;
	}
	public void setRegix(String regix) {
		this.regix = regix;
	}
	public String[] getData() {
		return data;
	}
	public Stream<String> stream(){
		return StreamSupport.stream(new MySpliterator(), false);
	}
	public Stream<String> parallelstream(){
		return StreamSupport.stream(new MySpliterator(), true);
	}
	public MySpliteratorText(String text, String regix) {
		Objects.requireNonNull(text, "The parameter text can not be null");
		this.data = text.split(regix);
	}
	//定义在MySpliteratorText的内部类
	public class MySpliterator implements Spliterator<String> {
		private int start, end;
	
		/**
		 * 无参构造函数
		 */
		public MySpliterator() {
			this.start = 0;
			this.end = data.length - 1;
		}

		/**
		 * 有参构造函数
		 * 
		 * @param start
		 * @param end
		 */
		public MySpliterator(int start, int end) {
			this.start = start;
			this.end = end;
		}

		@Override // 不管是并行还是费非并行，只要有元素就开始消费
		public boolean tryAdvance(Consumer<? super String> action) {
			if (start <= end) {// 元素是有的
				action.accept(data[start++]);// 消费当前元素
				return true;
			}
			return false;
		}

		@Override // 通过递归实现分而治之,将数组分开的功能 ,取中间值
		public Spliterator<String> trySplit() {
			int mid = (end - start) / 2;
			if (mid <= 0) {// 开始值与结尾值相同,不需要继续拆分spliterator
				return null;
			}
			// 如果还需要继续拆分
			int left = start;
			int right = start + mid;// 此处为拆分的第一部分的最后一个元素
			start = right + 1;// 重置start为拆分后第二部分的第一个元素
			return new MySpliterator(left, right);// 将拆分出来的spliterator返回
		}

		@Override//还有多少个元素
		public long estimateSize() {
			// TODO Auto-generated method stub
			return end-start;
		}
		@Override//当元素值已知，返回
		public long getExactSizeIfKnown() {
			// TODO Auto-generated method stub
			return estimateSize();
		}
		
		@Override//特征值设置为不可变的,大小固定的,可以取子集的
		public int characteristics() {
			// TODO Auto-generated method stub
			return IMMUTABLE|SIZED|SUBSIZED;
		}

	}
}
当如下操作:
 IntStream intStream =  IntStream.rangeClosed(0,100);
   intStream.parallele()//并行
            .filter()
            .sequential()//串行
            .map()
            .parallel()//并行
            .forEach();
 最终的操作只会按照你最后设定的parallel来并行!!!!!!!
**************************Spliterator**********************************************
**************************default*****************************************
//在顶层接口中添加一个default的方法，其它的子类不需要去实现它!!!
default Stream<E> stream(){
 return StreamSupport.stream(spliterator(),false);
}

1.class本身定义的方法的优先级最高
2.子接口定义的方法优先于父接口的同名方法
3.当C实现的A接口和B接口没有任何关系的时候，此时无法判断,必须重写该方法,
      在该方法中可以调任意继承接口的方法A.super.hello();/B.super.hello();
      
*****************CompletableFuture*******************************
************多线程Future设计模式**********************
	private interface Future<T> {
		T get();

		boolean isDone();
	}
	private interface Callable<T> {
		T action();// 做了一个动作返回一个我想要的结果给我
	}
	/**
	 * 异步执行
	 * 
	 * @param callable
	 * @return
	 */
	private static <T> Future<T> invoke(Callable<T> callable) {
		AtomicReference<T> result = new AtomicReference<>();
		AtomicBoolean flag = new AtomicBoolean(false);
		Thread t = new Thread(() -> {
			T value = callable.action();// 通过T action()获得一个值
			result.set(value);
			flag.set(true);
		});
		t.start();
		Future<T> future = new Future<T>() {
			@Override
			public T get() {
				// TODO Auto-generated method stub
				return result.get();
			}

			@Override
			public boolean isDone() {
				// TODO Auto-generated method stub
				return flag.get();
			}

		};
		return future;
	}// invoke
	
	public static void main(String[] args) {
		Future<String> future = invoke(() -> {
			try {
				Thread.sleep(10000);
				/**
				 * private interface Callable<T> { 
				 * T action();// 做了一个动作返回一个我想要的结果给我 
				 * }
				 */
				return "finish";
			} catch (Exception e) {
				e.printStackTrace();
				return "error";
			}
		});
		while (!future.isDone()) {
			try {
				Thread.sleep(10);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		System.out.println(future.get());
	}
************多线程Future设计模式**********************
***************异步回调*****************************
package com.river.core.jdk8.MultiThreads;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
/**
 * 回调
 * @author riverplant
 *
 */
public class FutureCallback {
	public static void main(String[] args) {
		Future<String> future =  invoke(()->{
        	   try {
        		   Thread.sleep(10000);
   				return "finish";
			} catch (Exception e) {
				return "error";
			}
           });
		/**
		 * 此处可以做其它的操作需求
		 */
		System.out.println(future.get());
		/**
		 * 这里可以设置回调
		 */
		future.setCompletable(new Completable<String>() {

			@Override//当请求操作完成
			public void complete(String t) {
				System.out.println(t);
			}

			@Override//当请求操作出线异常
			public void exception(Throwable error) {
				System.out.println(error);
			}
			
		});
	}

	/**
	 * 定义获得Future<T>的invoke(Callable<T>)
	 * 
	 * @param callable
	 * @return
	 */
	private static <T> Future<T> invoke(Callable<T> callable) {
		AtomicReference<T> result = new AtomicReference<T>();
		AtomicBoolean flag = new AtomicBoolean(false);
		Future<T> future = new Future<T>() {
			private Completable<T> completable;
			@Override
			public T get() {
				// TODO Auto-generated method stub
				return result.get();
			}
			@Override
			public boolean isDone() {
				// TODO Auto-generated method stub
				return flag.get();
			}
			@Override
			public void setCompletable(Completable<T> completable) {
                     this.completable = completable;
			}
			@Override
			public Completable<T> getCompletable() {

				return completable;
			}

		};
		Thread t = new Thread(() -> {
			try {
				T value = callable.action();
				result.set(value);
				flag.set(true);
				if (future.getCompletable() != null) {
					future.getCompletable().complete(value);
				}
			} catch (Throwable cause) {
				if (future.getCompletable() != null)
				future.getCompletable().exception(cause);
			}

		});
		t.start();

		return future;

	}

	/**
	 * 自定义一个Future<T>接口
	 * 
	 * @author riverplant
	 *
	 * @param <T>
	 */
	private interface Future<T> {
		T get();

		boolean isDone();

		void setCompletable(Completable<T> completable);

		Completable<T> getCompletable();
	}

	/**
	 * 
	 * @author riverplant
	 *
	 * @param <T>
	 */
	private interface Completable<T> {
		void complete(T t);// 完成后回调

		void exception(Throwable error);// 抛异常时回调
	}

	/**
	 * 
	 * @author riverplant 自定义一个Callable<T>接口
	 * @param <T>
	 */
	private interface Callable<T> {
		T action();
	}
}
***************异步回调*****************************
***************CompletableFuture**********************
private static double queryProduction(int i) {
		return get();
	}
private static double multiply(double value) {

		try {
			Thread.sleep(1000);

		} catch (Exception e) {
			e.printStackTrace();
		}
		return value * 10;

	}

private static void CompletableFuturedemo2() {
	ExecutorService executor = Executors.newFixedThreadPool(2, r -> {
			Thread t = new Thread(r);
			t.setDaemon(false);// 设置为非守护线程，不会随着主程序结束而实现自动退出
			return t;
		});
		List<Integer> productionIds = Arrays.asList(1, 2, 3, 4, 5);
		/**
		 * 
		 * <CompletableFuture<Double>> Stream<CompletableFuture<Double>>
		 * java.util.stream.Stream.map(Function<? super Integer, ? extends
		 * CompletableFuture<Double>> mapper)
		 */
		Stream<CompletableFuture<Double>> completableFuture = productionIds.stream()
				//i -> CompletableFuture.supplyAsync:用多线程进行处理
				//Function<? super Integer,
				.map(i -> CompletableFuture.supplyAsync(() -> queryProduction(i), executor));
		Stream<CompletableFuture<Double>> multiplayFuture = completableFuture
				//对结果进行加工
				.map(future -> future.thenApply(CompletableFutureAction::multiply));
		                    //对多线程处理的结果进行合并
		multiplayFuture.map(CompletableFuture::join).collect(Collectors.toList());
	}
CompletableFuture API:
1.supplyAsync
2.thenApply
3.whenComplete
4.handle
5.thenRun
6.thenAccept
7.thenCompose
8.thenCombine(合并)
9.thenAcceptBoth

10.runAfterBoth:两个CompletableFuture 都结束后执行的动作
		CompletableFuture.supplyAsync(() -> {
			System.out.println(Thread.currentThread().getName() + "is runnint");
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			return 1;
		}).runAfterBoth(CompletableFuture.supplyAsync(() -> {
			System.out.println(Thread.currentThread().getName() + "is runnint");
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			return 2;
		}), () -> {
			System.out.println("done");
		});
11.applyToEither:当其中的一个执行完就传递给function 
		CompletableFuture.supplyAsync(()->{
			System.out.println("future 1");
			return CompletableFutureAction.get();
		}).applyToEither(CompletableFuture.supplyAsync(()->{
			System.out.println("future 2");
			return CompletableFutureAction.get();
		}),v->v*10)
		.thenAccept(System.out::println);
12.acceptEither:谁先完成就传递给一个consumer:accept(T t)
	CompletableFuture.supplyAsync(()->{
			System.out.println("future 1");
			return CompletableFutureAction.get();
		}).acceptEither(CompletableFuture.supplyAsync(()->{
			System.out.println("future 2");
			return CompletableFutureAction.get();
		}),System.out::println);
13.runAfterEither:有一个运行结束后运行一个runnable
CompletableFuture.supplyAsync(()->{
			System.out.println("future 1");
			return CompletableFutureAction.get();
		}).runAfterEither(CompletableFuture.supplyAsync(()->{
			System.out.println("future 2");
			return CompletableFutureAction.get();
		}),()->System.out.println("done..."));//可以记录日志

14.anyOf(静态方法)：有一个执行完就处理
				List<CompletableFuture<Double>> collect = Arrays.asList(1,2,3,4)
						              .stream()
				                      .map(i->CompletableFuture.supplyAsync(CompletableFutureAction::get))
				                      .collect(Collectors.toList());//获得一个CompletableFuture的list
				//CompletableFuture.allOf需要一个数组
				CompletableFuture.anyOf(collect.toArray(new CompletableFuture[collect.size()]))
				.thenRun(() ->System.out.println("done..."));
				
15.allOf(静态方法):全部执行完后再处理
		List<CompletableFuture<Double>> collect = Arrays.asList(1,2,3,4)
				              .stream()
		                      .map(i->CompletableFuture.supplyAsync(CompletableFutureAction::get))
		                      .collect(Collectors.toList());//获得一个CompletableFuture的list
		//CompletableFuture.allOf需要一个数组
		CompletableFuture.allOf(collect.toArray(new CompletableFuture[collect.size()]))
		.thenRun(() ->System.out.println("done..."));
***************CompletableFuture**********************
****************DateAPI*******************************



****************DateAPI*******************************
