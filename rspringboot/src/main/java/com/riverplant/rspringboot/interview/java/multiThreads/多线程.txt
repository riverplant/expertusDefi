Java多线程:
1.进程和线程的区别:进程是资源分配的最小单位(PCB),线程是CPU调度的最小单位

2.start和run方法:start()会创建一个新的子线程并启动(JVM_StartThread中创建thread_entry)
     ，run()是Thread的一个普通方法调用
3.Thread和Runnalbe的关系:Thread是class, Runnable是接口
   因为类的单一继承，推荐多使用Runnable接口
   run()方法传参：1.构造函数2.成员变量3.回调函数

4.处理线程的返回值
   ->主线程等待法:
   ->join()
   ->Callable接口，通过FutureTask Or线程池获取
5.线程池
->new :创建后未启动
->runnable:Running(在运行中) 和 Ready(等待中)
->waiting:等待被唤醒 Thread.sleep(); Object.wait();  Thread.join();   LockSupport.park();  
->Timed Waiting:限期等待,一定时间后系统会自动唤醒
->Blocked阻塞:等待获取排它锁,进入synchronized区域时会变成Blocked状态
->Terminated:终止状态

6.sleep(Thread的方法)和wait(Object方法)
->sleep可以在任何地方使用，wait只能在synchronized方法或者synchronized块中使用
->Thread.sleep不会导致锁行为的改变
->Object.wait将会让出锁
public class WaitSleepDemo {
public static void main(String[] args) {
	final Object lock = new Object();
	new Thread(()-> {//A
		System.out.println("thread A is waiting to get lock");
		synchronized(lock) {
			System.out.println("thread A get lock");
			try {
				Thread.sleep(20);//不会释放锁，所以B此时得不到锁不能执行synchronized块，只能阻塞
				System.out.println("thread A do wait");
				lock.wait(1000);//此时A会释放锁lock,让B开始执行,线程A将进入等待池
			} catch (Exception e) {
				e.printStackTrace();
			}	
		}
	} ).start();
	
	try {
		Thread.sleep(10);
	} catch (Exception e2) {
		e2.printStackTrace();
	}
	new Thread(()-> {//B
		System.out.println("thread B is waiting to get lock");
		synchronized(lock) {
			System.out.println("thread B get lock");
			try {
				System.out.println("thread B is sleeping 10 ms");
				Thread.sleep(10);
				System.out.println("thread B is done");
				lock.notifyAll();
			} catch (Exception e) {
				e.printStackTrace();
			}	
		}
	} ).start();
}}
notify和notifyAll的区别:
->锁池:EntryList:当线程等待的锁被其它线程拿到，该线程就会进入锁池进行等待

->等待池:WaitSet：当拿到锁的线程调用了wait()方法释放了自己的锁，该线程就会进入等待池，不去竞争该对象的锁

notifyAll:让所有等待池中的线程全部进入锁池去竞挣锁
notify:随机选取一个等待池中的线程进入锁池中

*********************yield函数**********************************************
Thread.yield():通知线程调度器，当前线程愿意让出CPU，但是线程调度器可能会忽略这个暗示

public class YieldDemo {

	public static void main(String[] args) {
		
		Runnable yieldTask = new Runnable() {
			
			@Override
			public void run() {
				for(int i=0;i<10;i++) {
					System.out.println(Thread.currentThread().getName()+i);
					if(i==5)Thread.yield();//当t1执行到5，可能会让给t2
				}	
			}
			};//yieldTask
			Thread t1 = new Thread(yieldTask,"t1");
			Thread t2 = new Thread(yieldTask,"t2");
			t1.start();t2.start();
	}
}
***************************interrupt函数************************
interrupt()  通知线程应该中断了
->如果线程处于被阻塞状态，那么线程会立刻退出被阻塞状态，并且抛出InterruptedException异常
->如果线程处于正常活动，会将该线程的中断标志设置为true,该线程将继续正常运行，不受影响
->需要被调用的线程配合中断
public class InterruptDemo {
public static void main(String[] args) throws InterruptedException {
	Runnable Interruptask = new Runnable() {
		@Override
		public void run() {
		int i = 0;
		try {
			while(!Thread.currentThread().isInterrupted()) {
				Thread.sleep(100);//当休眠时线程相当于处于阻塞，此时如果调用interrup指令，将会退出阻塞并且抛出异常
				i++;
				System.out.println(Thread.currentThread().getName()+"("+Thread.currentThread().getState()+") loop "+i);
			}
		} catch (InterruptedException e) {//调用阻塞方法时处理InterruptedException
			System.out.println(Thread.currentThread().getName()+"("+Thread.currentThread().getState()+")");
		}	
		}	
	};//task
	Thread t1 = new Thread(Interruptask,"t1");
	System.out.println(t1.getName()+"("+t1.getState()+") is new");
	t1.start();//启动t1
	System.out.println(t1.getName()+"("+t1.getState()+") is started");
	Thread.sleep(300);
	t1.interrupt();//向t1发送中断指令
	System.out.println(t1.getName()+"("+t1.getState()+") is interrupted");
	Thread.sleep(300);
	System.out.println(t1.getName()+"("+t1.getState()+") is interrupted now.");
}
}

***************************************synchronized**********************************
互斥锁的特性:
    -> 在同一个时间只容许一个线程持有摸个对象锁
    -> 在锁被释放之前,对共享变量所做的修改，对于随后获得该锁的另外一个线程是可见的
    
synchronized锁的不是代码，都是对象
->获取对象锁: 同步代码块，  同步非静态方法synchronized method:当Thread传入的参数为new SyncThread()时
，转变为异步锁，因为该锁的对象为类的对象，所以new SyncThread()为不同的对象锁
public class SyncThread implements Runnable {

	@Override
	public void run() {
		String threadName = Thread.currentThread().getName();
		if (threadName.startsWith("A")) {
			async();
		} else if (threadName.startsWith("B")) {
			syncObjectBlock1();
		} else if (threadName.startsWith("C")) {
			syncObjectMethod1();
		}
	}

	/**
	 * 异步方法
	 */
	private void async() {
		try {
			System.out.println(Thread.currentThread().getName() + "_Async_Start: " + LocalDateTime.now().toString());
			Thread.sleep(1000);
			System.out.println(Thread.currentThread().getName() + "_Async_End: " + LocalDateTime.now().toString());
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
   /**
    * 同步代码块
    */
	private void syncObjectBlock1() {
		System.out.println(
				Thread.currentThread().getName() + "_syncObjectBlock1_Block1: " + LocalDateTime.now().toString());
		synchronized (this) {//同步代码块
			try {
				System.out.println(Thread.currentThread().getName() + "_syncObjectBlock1_Start: "
						+ LocalDateTime.now().toString());
				Thread.sleep(1000);
				System.out.println(
						Thread.currentThread().getName() + "_syncObjectBlock1_End: " + LocalDateTime.now().toString());
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
   /**
    * 同步方法
    */
	private synchronized void syncObjectMethod1() {
		System.out.println(
				Thread.currentThread().getName() + "_syncObjectMethod1: " + LocalDateTime.now().toString());
		try {
			System.out.println(
					Thread.currentThread().getName() + "_syncObjectMethod1_Start: " + LocalDateTime.now().toString());
			Thread.sleep(1000);
			System.out.println(
					Thread.currentThread().getName() + "_syncObjectMethod1_End: " + LocalDateTime.now().toString());
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}

->获得类锁的两种方法:当Thread传入的参数为new SyncThread()时，依然为同步锁，因为该锁的对象时类本身
  同步代码块(synchronized (类.class);
 同步静态方法(synchronized static method) 锁是当前对象的类对象
    
     /**
    * 同步静态方法(synchronized static method) 锁是当前对象的类对象
    */
	private synchronized static void syncMethod1() {
		System.out.println(
				Thread.currentThread().getName() + "_syncObjectMethod1: " + LocalDateTime.now().toString());
		try {
			System.out.println(
					Thread.currentThread().getName() + "_syncObjectMethod1_Start: " + LocalDateTime.now().toString());
			Thread.sleep(1000);
			System.out.println(
					Thread.currentThread().getName() + "_syncObjectMethod1_End: " + LocalDateTime.now().toString());
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	//同步代码块(synchronized (类.class);
	private void syncBlock1() {
		System.out.println(
				Thread.currentThread().getName() + "_syncObjectBlock1_Block1: " + LocalDateTime.now().toString());
		synchronized (SyncThread.class) {//同步代码块
			try {
				System.out.println(Thread.currentThread().getName() + "_syncObjectBlock1_Start: "
						+ LocalDateTime.now().toString());
				Thread.sleep(1000);
				System.out.println(
						Thread.currentThread().getName() + "_syncObjectBlock1_End: " + LocalDateTime.now().toString());
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
 *******************************************MarkWord************************************
 
  **************************ReentrantLock(再入锁)java.util.concurrent.locks************************************
 /**
 * 公平锁
 * @author riverplant
 *
 */
public class ReentrantLockDemo implements Runnable{
    //true:为公平锁
	private static ReentrantLock lock = new ReentrantLock(true);
	@Override
	public void run() {
		while(true) {
			try {
				lock.lock();//获得了锁
				System.out.println(Thread.currentThread().getName()+" get lock");
				Thread.sleep(1000);
			} catch (Exception e) {
				e.printStackTrace();
			}finally {
				lock.unlock();
			}
		}
	}
}
****************************自旋锁与自适应自旋锁***************************** 
通过让线程执行忙循环等待锁的释放，不让出CPU
*********************************JMM:java memory model*********************
happens-before:
************************CAS(Compare and Swap)*******************************
public class CasDemo {

	private static volatile int value = 0;
	
	public static AtomicInteger add() {
		AtomicInteger val = new AtomicInteger(value);
		val.getAndIncrement();
		return val;
	}
	
	public static void main(String[] args) {
		AtomicInteger val = add();
		System.out.println(val.get());
	}
}
***********************线程池Executors************************************
1.Executor:运行新任务的简单接口 void execute(Runnable command)//只有一个方法
  Thread t = new Thread();
  executor.execute(t);//不需要t.start();
2.ExecutorService:可以返回future    <T> Future<T> submit(Callable<T> task);
3.ScheduledExcetorService: 支持Future和定期执行任务
4.ThreadPool维护的是一组Work对象:
5.ThreadPoolExecutor的构造函数:
   -> corePoolSize: 核心线程数量
   -> maximumPoolSize: 线程不够时能创建的最大线程数
   -> workQueue: 任务等待队列
   -> keepAliveTime: 抢占的顺序不一定
   -> threadFactory: 创建新线程,Executors.defaultThreadFacotry()//非守护线程
   -> handler: 线程池的饱和策略
 
 线程池的状态：
 1.running:能接受新提交的任务，能处理阻塞队列中的任务
 2.shutdown:不再接受新提交任务，可以处理存量任务
 3.running->shutdownnow()->stop:不再接受新任务，也不处理存量任务
 4.tydying:所有任务已经终止
 5.terminated:标识  
 线程数大小：
   