@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration  :相当于spring提供的Configuration
@EnableAutoConfiguration ：自动配置
@ComponentScan(excludeFilters = { //ComponentScan:启用了自动扫描，所有用了@Component注解的类都会被注入
		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication


***********************************************************************************

@SpringBootApplication
public class App 
{
	@Bean
	public Runnable createRunnable() {
		return ()->{System.out.println("Spring boot is started");};
	}
    public static void main( String[] args )
    {

    	ConfigurableApplicationContext context = SpringApplication.run(App.class, args);
    	context.getBean(Runnable.class).run();
    	System.out.println(context.getBean(User.class));
    }
}


******************************配置分析************************************************

路径：src/main/resources/application.properties   classpath目录
     src/main/resources/config/application.properties   classpath:/config目录
     
1. ConfigurableApplicationContext context = SpringApplication.run(App.class, args);
String ip = context.getEnvironment().getProperty("river.local.ip");

2.
 * 
 * @author riverplant
 * 获取配置的方法
 */
@Component
public class UserConifg {
	@Autowired
	private ConfigurableEnvironment env;
	@Value("${river.port}")
	private String port;

	public String getIp() {
		String ip = env.getProperty("river.local.ip");
		//System.out.println("river.local.ip = " + ip);
		return ip;
	}

	@Override
	public String toString() {
		return "UserConifg [river.local.ip=" + getIp() + ", port=" + port + "]";
	}
	
});
    	context.close();
    	
-> 修改配置文件名称为app:右键run下面的configuration: arguments: 
--spring.config.name=app  扩展名省略
--spring.config.location=classpath::config/app.properties
-----------------指定多个配置文件(需要指定全路径：包括目录、文件名字、文件后缀)!!!!--------------------------------
--spring.config.location=classpath::config/app.properties,file:E:/file/tomcat.properties
-->classpath
-->file

//通过FileConfig来添加配置文件@PropertySource("classpath:config/jdbc.properties")
@Configuration
@PropertySource("classpath:config/jdbc.properties")
//@PropertySource("file:/e/jdbc.properties") 可以指定多个配置文件，包括classpath:config和file:
//@PropertySources({@PropertySource("classpath:config/jdbc.properties"),@PropertySource("file:/e/jdbc.properties")})
public class FileConfig {}

//通过JdbcConfig来读取配置项
@Component
public class JdbcConfig {
    @Value("${url}")
	private String url;
    @Value("${driverClassName}")
	private String driverClassName;

	@Override
	public String toString() {
		return "JdbcConfig [url=" + url + ", driverClassName=" + driverClassName + "]";
	}}

3.@Component
@ConfigurationProperties(prefix="river")//通过配置前缀来获取
public class DataSourceProperties {
private String url;//属性名必须和配置名字一致
private String driverClassName;
private String username;
private String password;
public String getUrl() {
	return url;
}
public void setUrl(String url) {
	this.url = url;
}
public String getDriverClassName() {
	return driverClassName;
}
public void setDriverClassName(String driverClassName) {
	this.driverClassName = driverClassName;
}
public String getUsername() {
	return username;
}
public void setUsername(String username) {
	this.username = username;
}
public String getPassword() {
	return password;
}
public void setPassword(String password) {
	this.password = password;
}
@Override
public String toString() {
	return "DataSourceProperties [url=" + url + ", driverClassName=" + driverClassName + ", username=" + username
			+ ", password=" + password + "]";
}	
}

*******************MyEnvironmentPostProcessor implements EnvironmentPostProcessor***********
通过实现EnvironmentPostProcessor接口动态初始化配置文件：
public class MyEnvironmentPostProcessor implements EnvironmentPostProcessor {
	public static final String SPRINGBOOTPROPERTIE = "config/springboot.properties";
	
	@Override
	public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		
		String filePath = Thread.currentThread().getContextClassLoader().getResource(SPRINGBOOTPROPERTIE).getPath();

		System.out.println(filePath);
		try(InputStream stream = new FileInputStream(new File(filePath))) {
			Properties source = new Properties();
			source.load(stream);
			PropertiesPropertySource propertySource = new PropertiesPropertySource("myPropertiesPropertySource", source);
			environment.getPropertySources().addLast(propertySource);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
因为该接口是springboot的不是原生的spring接口所以需要在META-INF/spring.factories文件中注册(写在一行):
org.springframework.boot.env.EnvironmentPostProcessor=com.riverplant.rspringboot.processors.MyEnvironmentPostProcessor

****************************在不同的环境下载入不同的配置**************************************
1. SpringApplication app = new SpringApplication(App.class);
    	app.setAdditionalProfiles("test","dev");//指定载入application-test.properties,可以指定多个
    	ConfigurableApplicationContext context = app.run(args);
    	
2.通过指定参数:--spring.profiles.active=test,dev  可以指定多个

3.@SpringBootConfiguration
public class MyConfig {
	@Bean
	public Runnable createRunnalbe() {
		return ()->{System.out.println("======defualtRunnalbe====");};
	}	
	@Bean
	@Profile("dev")//只有当dev配置文件被激活才会注入
	public Runnable createRunnalbeDev() {
		return ()->{System.out.println("======RunnalbeDev====");};
	}	
	@Bean
	@Profile("test")//只有当test配置文件被激活才会注入
	public Runnable createRunnalbeTest() {
		return ()->{System.out.println("======RunnalbeTest====");};
	}
}

**********************org.springframework.boot.autoconfigure.condition***根据条件自动配置*******************************************
1.public interface MyEncodingConvert {}
2.public class Utf8EncodingConvert implements MyEncodingConvert {}
  public class GbkEncodingConvert2 implements MyEncodingConvert {}

3.@SpringBootConfiguration
[@Conditional({MyEncodingCondition.class,...})]////可以注解在类上或者方法上，可以注解多个condition,只有都返回true才会装配
public class MyEncodingConvertConfig {
    @Bean
    @Conditional(MyEncodingCondition.class)//该注解对应的MyEncodingCondition类定义在下面
	public MyEncodingConvert createUtf8EncodingConvert() {
		 return new Utf8EncodingConvert();
	}  
    @Bean
    @Conditional(MyEncodingCondition.class)//该注解对应的MyEncodingCondition类定义在下面
   	public MyEncodingConvert createGBKEncodingConvert() {
   		 return new GbkEncodingConvert2();
   	}
}

4.public class MyEncodingCondition implements Condition {
	private static final String ENCODINGUTF8 = "utf-8";
	private static final String ENCODINGGBK = "gbk";
	@Override//返回true进行自动配置，返回false不配置
	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
		boolean flag = false;
		String encoding = System.getProperty("file.encoding");
		if(encoding!=null) {
			if( ENCODINGUTF8.equalsIgnoreCase(encoding)) {
				flag = true;
				System.out.println("encoding is utf-8");
			}else if(ENCODINGGBK.equalsIgnoreCase(encoding)) {
				flag = true;
				System.out.println("encoding is gbk");
			}
		}
		return flag;
	}
}

public @interface ConditionalOnJava:根据jvm版本号来控制

 @Bean
 //必须配置文件中配置了runnable.enable=true
 //matchIfMissing=true:如果没有该配置项，默认为true
 @ConditionalOnProperty(name="runnable.enable",havingValue="true",matchIfMissing=true)
 public Runnable createRunnable() {
		return ()->{System.out.println("Spring boot is started");};
	}
	
@ConditionalOnClass:当classpath中有某个类的时候进行装配
@Bean
	@ConditionalOnClass(name="com.google.gson.Gson")//当classpath中有Gson类的时候装配
	public Runnable createGsonRunnalbe() {
		return ()->{System.out.println("======GsonRunnalbe====");};
	}
此时需要在maven中引进Gson
<dependency>
			<groupId>com.google.code.gson</groupId>
			<artifactId>gson</artifactId>
		</dependency>
		
@Bean
	@ConditionalOnBean(name="User")//当有一个bean存在的时候装配
	public Runnable createBeanRunnalbe() {
		return ()->{System.out.println("======BeanRunnalbe====");};
	}
***********************************根据条件自动配置****************************************************
*************************@Enable：启用功能特性的注解******************************************************
@EnableConfigurationProperties:用来启用一个特性的，该特性为可以把配置文件中的属性注入到bean里

@Component
public class User implements Runnable{
	@Override
	@Async//指定该方法为异步
	public void run() {
		try {
			for(int i=0;i<10;i++) {
				System.out.println("i="+i);
				TimeUnit.SECONDS.sleep(1);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}		
	}
}
@SpringBootApplication
@EnableAsync//启用异步
public class App {}
---------------------通过@Import来加载Bean对象-------------------------------------

@SpringBootApplication
@EnableAsync//启用异步
@Import({User.class,role.class,MyConfiguration.class})//通过@Import来加载User Bean对象
public class App 
{
    public static void main( String[] args ) throws URISyntaxException
    {
    	ConfigurableApplicationContext context = SpringApplication.run(App.class, args);
    	System.out.println(context.getBean(User.class).toString());
    	context.close();
    }
}
*************************@Enable：启用功能特性的注解***********************************************
/**
 * 
 * @author riverplant
 * 该类中selectImports方法的返回值为一个动态指定的类数组，该数组中的类被String容器托管
 */
public class MyImportSelector implements ImportSelector {
	@Override
	public String[] selectImports(AnnotationMetadata importingClassMetadata) {
		//动态导入User和MyConfig
		return new String[] {User.class.getName(),MyConfig.class.getName()};
	}
}
**************************annotation引用MyImportSelector******
@Import(MyImportSelector.class)
public @interface EnableLog {
String name();
}
在MyImportSelector类中可以获得该注解的属性
public class MyImportSelector implements ImportSelector {
	@Override
	public String[] selectImports(AnnotationMetadata importingClassMetadata) {
		//获得引用了该类的注解的属性
		importingClassMetadata.getAnnotatedMethods(EnableLog.class.getName());
		//可以根据获得的注解详细信息来动态的返回需要被Spring容器管理的bean
		//动态导入User和MyConfig
		return new String[] {User.class.getName(),MyConfig.class.getName()};
	}
}
******************ImportBeanDefinitionRegistrar接口*************************
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata
, BeanDefinitionRegistry registry){}

public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {

	@Override//通过BeanDefinitionRegistry来动态注入bean
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
		MultiValueMap<String, Object> map =   importingClassMetadata.getAllAnnotationAttributes(EnableLog.class.getName());
		System.out.println(map); //打印出:name=my springboot
		BeanDefinitionBuilder bdb = BeanDefinitionBuilder.rootBeanDefinition(User.class);
		BeanDefinition beanDefinition = bdb.getBeanDefinition();
		registry.registerBeanDefinition("user", beanDefinition);
	}}
	
****************************练习:************************************
1./**
 * 自定义注解
 * @author riverplant
 *
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import({MyImportBeanDefinitionRegistrar.class})//将要进行处理的MyImportBeanDefinitionRegistrar引入
public @interface EnableLog {
//String name();
String[] packages();//只要bean的包在packages里，就打印出该对象
}

2.public class MyBeanPostProcessor implements BeanPostProcessor {

	private List<String> packages;
	
	public List<String> getPackages() {
		return packages;
	}

	public void setPackages(List<String> packages) {
		this.packages = packages;
	}

	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		for(String pack:packages) {
			if(bean.getClass().getPackage().getName().equalsIgnoreCase(pack)) {
				System.out.println("该bean的名字是:"+bean.getClass()+";输入"+pack+"包");
			}
		}
		return bean;
	}
	
	@Override
	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		return bean;
	}
}

3.public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {

	@Override//通过BeanDefinitionRegistry来动态注入bean
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
		Map<String, Object> map =   importingClassMetadata.getAnnotationAttributes(EnableLog.class.getName());
		String[] packArr = (String[]) map.get("packages");
		List<String> packages = Arrays.asList(packArr);
		System.out.println("packages="+packages);
		BeanDefinitionBuilder bdb = BeanDefinitionBuilder.rootBeanDefinition(MyBeanPostProcessor.class);
		bdb.addPropertyValue("packages", packages);//通过该方法给MyBeanPostProcessor中的packages属性初始化
		BeanDefinition beanDefinition = bdb.getBeanDefinition();
		registry.registerBeanDefinition("myBeanPostProcessor", beanDefinition);
	}
	
4.@SpringBootApplication
@EnableAsync//启用异步
//@EnableLog(packages= {"com.riverplant.rspringboot.beans","com.riverplant.rspringboot.config"})
@EnableLog(packages= {"com.riverplant.rspringboot.beans"})
public class App 
{
    public static void main( String[] args ) throws URISyntaxException
    {
    ConfigurableApplicationContext context = SpringApplication.run(App.class, args);
   	System.out.println(context.getBeansOfType(Runnable.class));
    context.close();
    }	
    
@EnableAutoConfiguration  如果在配置文件中指定spring.boot.enableautoconfiguration=false
将无法执行自动配置
  
//该方法用于读取/META-INF/spring.factories里面的内容   
List<String> configurations = SpringFactoriesLoader.LoadFactoryNames(
getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader())
************************************************************************************
*******************************jsp********************
配置文件中
spring.mvc.view.prefix=	/WEB-INF/JSP
spring.mvc.view.suffix=.jsp	