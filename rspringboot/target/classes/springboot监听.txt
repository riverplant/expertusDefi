1.自定义事件，继承ApplicationEvent抽象类
/**
 * 自定义监听的事件
 * @author riverplant
 *
 */
public class MyApplicationEvents extends ApplicationEvent {

	private static final long serialVersionUID = 1L;

	public MyApplicationEvents(Object source) {
		super(source);		
	}
}

2.定义事件监听器，实现ApplicationListener接口
//指定监听类型为MyApplicationEvents
public class MyApplicationListener implements ApplicationListener<MyApplicationEvents> {

	@Override
	public void onApplicationEvent(MyApplicationEvents event) {	
	System.out.println("接收到事件"+event.getClass());
	}
}

3.发布事件
@SpringBootApplication
public class App 
{
    public static void main( String[] args )
    {
    	SpringApplication app = new SpringApplication(App.class);
    	ApplicationListener<MyApplicationEvents>  applicationListener = new MyApplicationListener();
    	app.addListeners(applicationListener);//需要把监听器加入到spring容器中
    	//2.或者通过注解@Component将监听器加入Spring容器
    	//3.通过配置文件添加#context.listener.class=com.riverplant.rspringboot.listener.MyApplicationListener
    	//4.在方法上使用@EventListener注解，该类加入到Spring容器中管理
    	ConfigurableApplicationContext context = app.run(args);
    	context.publishEvent(new MyApplicationEvents(new Object()));//发布事件
    	context.close();
    }
 }
 
//通过自定义handle来实现事件的监听
 @Component
public class MyEventHandle {
    /**
     * 参数必须是ApplicationEvent或者其子类
     * @param event:指定事件参数将会专门监听该事件，
     *如果写成Object event将会监听所有的ApplicationEvent或者其子类事件
     */
	@EventListener
	public void event(MyApplicationEvents event) {
		System.out.println("MyEventHandle 收到事件: "+event.getClass());
	}
}

org.spirngframework.context.event

@Component
public class MyContextHandler {
    @EventListener
	public void event(ContextClosedEvent event) {
    	
		System.out.println("context 关闭时间为:"+event.getTimestamp());
	}
}
****************************ApplicationContextInitializer接口***************************************************
1.实现ApplicationContextInitializer接口
public class MyApplicationContextInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext> {
	@Override
	public void initialize(ConfigurableApplicationContext applicationContext) {
	    System.out.println("当前容器中有"+applicationContext.getBeanDefinitionCount()+"个Bean");
	    ConfigurableListableBeanFactory  beanFactory = applicationContext.getBeanFactory();
	    /**
	     * BeanDefinitionBuilder bdb = BeanDefinitionBuilder.rootBeanDefinition(MyBeanPostProcessor.class);
		 bdb.addPropertyValue("packages", packages);//通过该方法给MyBeanPostProcessor中的packages属性初始化
		 BeanDefinition beanDefinition = bdb.getBeanDefinition();
		 registry.registerBeanDefinition("myBeanPostProcessor", beanDefinition);
	     */
	    BeanDefinition  bd = beanFactory.getBeanDefinition("User");
	    System.out.println("通过BeanDefinition获得的bean是"+bd.getBeanClassName());
	}
}
   	SpringApplication app = new SpringApplication(App.class);
    app.addInitializers(new MyApplicationContextInitializer());//通过该方法将ApplicationContextInitializer加载
    
2.通过配置文件配置项指定(可以指定多个):context.initializer.classes=com.riverplant.rspringboot.impl.MyApplicationContextInitializer
3.通过spring.factories来配置:org.springframework.context.ApplicationContextInitializer=...

**************************************CommandLineRunner*************************************
1.Spring容器全部初始化完了之后的最后一个回调
public interface CommandLineRunner{
void run(String... arg);//通常使用main方法中的参数arg
}
2.自定义接口的实现类
@Component
public class MyCommandLineRunnerImpl implements CommandLineRunner {

	@Override
	public void run(String... args) throws Exception {//参数为原始参数
		System.out.println("==========应用已经成功的启动=================");
		}}

**************************************ApplicationRunner*************************************
1.与CommandLineRunner功能相同，不同处在于参数类型不同
public interface ApplicationRunner{
void run(ApplicationArguments... arg);//参数为ApplicationArguments,对原始参数进一步封装
}

2.public interface ApplicationArguments:对参数(main方法)做进一步处理，可以解析--name=value,可以通过name来获得value
****************************************************************************

@SpringBootApplication(scanBasePackages="com.riverplant.rspringboot"):指定扫描的包

app.setBannerMode(Banner.Mode.OFF);//设置启动不打印标记,可以在src/main/resources下面定义一个banner.txt                       