springboot实战

1.<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.1.2.RELEASE</version>
		<relativePath /> <!-- lookup parent from repository -->
	</parent>
2.<!-- springboot web -->
  	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
2.controller:
/**
     * @RequestParam("username") String usernam:将http中的请求参数username赋值给usernam
     * @param username
     * @param password
     * @return
     */
@ResponseBody
    @PostMapping("/create")
    public String create(@RequestParam(value = "username",defaultValue="admin") String username,@RequestParam(value="password",required=false)String password) {
    	
    	return "user create:username="+username+" || password="+password;
    }
    
 **************************jsp**************************************
 
 @Controller
public class LoginController {
	Logger log = LoggerFactory.getLogger(getClass());
	
    @PostMapping("/login")
	public String login(@RequestParam(value="username",defaultValue="admin")String username,@RequestParam(value="password",defaultValue="admin")String password) {
    	System.out.println(username+"loging at "+LocalDateTime.now().toString());
    	if(username.equals(password)) {
    		return "loginSuccess";//表示在/WEB-INF/JSP下找loginSuccess.jsp
    	}
    	return "loginFaild";//表示在/WEB-INF/JSP下找loginFaild.jsp
	}
   
    
    @GetMapping("/login")
    public String loginIndex(Model model) {
    	model.addAttribute("username", "tester1");
    	return "login";
    }
    
    @GetMapping("/index")
    public String Index(Model model) {
    	model.addAttribute("username", "tester1");
    	return "index";
    }
	
}
 #配置jsp:绝对不要有空格
spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp
 
 
    
 **********************springboot中使用模板,必须关闭jsp******************************
 1.freemarker:
 默认文件路径:classpath:/templates/       /resources/templates/ref.ftl
 默认文件扩展名:ftl
 
在配置文件中修改:可以配置多个路径
spring.freemarker.templateLoaderPath=classpath:/ftl,classpath:/templates/

 <h1>ft1 ref</h1>
 @Controller
public class AccountController {
    @GetMapping("/ref")
	public String reg() {
		return "ref";
	}
}
2.传递参数
 @GetMapping("/logout")
   	public String logout(Model model) {
    	model.addAttribute("username", "root");
    	model.addAttribute("logout", "true");
   		return "logout";
   	}
   	
 <h1>logout page</h1>
<h2>username is ${username}</h2><h3>logout is ${logout}</h3>
************************访问静态资源***********************************
 1.webapp下直接访问html,jpg...
 2.在ResouceProperties.class中定义了
 private static final String[] CLASSPATH_RESOURCE_LOCATIONS={
 "classpath:/META-INF/resources/",
 "classpath:/resources/",
 "classpath:/static/",
 "classpath:/public/"
 }
 ------------classpath:src/main/resources-----------------------------------
可以在配置文件中通过 spring.resouces.staticLocations=classpath:/htmal1,classpath:/htmal2...来修改,可以设置多个
都可以放静态资源

***********************************************servlet*****************************************
1.@WebServlet("/user.do")
public class MyServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;	
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
	resp.getWriter().print("user servlet");
}
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
	this.doGet(req, resp);
}}
2.通过注解@ServletComponentScan将servlet注入spring容器中

**************************filter*************************************
@WebFilter("/*")
public class LogFilter implements Filter{
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		System.out.println("income log filter"+request.getRemoteHost());
		chain.doFilter(request, response);
		
	}
	@Override
	public void destroy() {
		// TODO Auto-generated method stub
		Filter.super.destroy();
	}
}
******************************listener****************************************
@WebListener
public class MyServletContextListener implements ServletContextListener {

	@Override
	public void contextInitialized(ServletContextEvent sce) {
		Dynamic dynamic = sce.getServletContext().addFilter("logFilter", LogFilter.class);
		
		System.out.println("app starup at "+LocalDateTime.now().toString());
	}
	
	@Override
	public void contextDestroyed(ServletContextEvent sce) {
		
	}
}

public class BookeFilter implements Filter {
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		System.out.println("bookFilter...."+request.getRemoteHost());
		chain.doFilter(request, response);
	}

}

通过配置类来注入filter 和servlet
@SpringBootConfiguration
public class ServletConfiguration {
    @Bean
	public ServletRegistrationBean<BookServlet> createServelt() {
		ServletRegistrationBean<BookServlet> servletRegistrationBean  = new ServletRegistrationBean<>(new BookServlet(),"/book.do");
		return  servletRegistrationBean;
	}
    @Bean
    public FilterRegistrationBean<BookeFilter > createFilter(){
    	FilterRegistrationBean<BookeFilter> filterRegistrationBean = new FilterRegistrationBean<>();
    	filterRegistrationBean.setFilter(new BookeFilter());
    	filterRegistrationBean.setUrlPatterns(Arrays.asList("/book.do"));
    	return filterRegistrationBean;
    }
    
//    @Bean
//    public ServletListenerRegistrationBean<MyStarupListener> createListener(){
//    	ServletListenerRegistrationBean<MyStarupListener> filterRegistrationBean = new ServletListenerRegistrationBean<>();
//    	filterRegistrationBean.setListener(new MyStarupListener());
//    	return filterRegistrationBean;
//    }
}
********************************拦截器********************************************************
在controller调用之前触发:
1.handlerInterceptor-> 
boolean preHandle:如果返回false,将不会触发controller
2.
public class MyHandlerInteceptor implements HandlerInterceptor {
	@Override//controller执行之前调用方法
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {	
		System.out.println("==============MyHandlerInteceptor.preHandle========"+handler.getClass());
		return true;//如果返回false将不会进入controller
	}

	@Override//controller执行之后，页面渲染之前调用
	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
			ModelAndView modelAndView) throws Exception {
		System.out.println("==============MyHandlerInteceptor.postHandle========");
		HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
	}

	@Override//在controller调用后，页面渲染后调用，一般用于资源清理
	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
			throws Exception {
		System.out.println("==============MyHandlerInteceptor.afterCompletion========");
		HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
	}
}

3.通过WebConfiguration装配，继承WebMvcConfigurationSupport，重写addInterceptors方法
@SpringBootConfiguration
public class WebConfiguration extends WebMvcConfigurationSupport {
	@Override
	protected void addInterceptors(InterceptorRegistry registry) {
		registry.addInterceptor(new MyHandlerInteceptor())
		.addPathPatterns("/**")
		.excludePathPatterns("/login","/ref");
		super.addInterceptors(registry);
	}
}
**********************************异常处理********************************************************
1.排除Spring默认的错误处理
@SpringbootApplication(exclude=ErrorMvcAutoConfiguration.class)

2.自定义错误页面：创建静态页面404.html,500.html

3.自定义错误处理类，通过实现ErrorPageRegistrar接口
@Component
public class MyCommonErrorRegistry implements ErrorPageRegistrar {
	@Override
	public void registerErrorPages(ErrorPageRegistry registry) {
		ErrorPage e404 = new ErrorPage(HttpStatus.NOT_FOUND, "/404.html");
		ErrorPage e500 = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, "/500.html");
		registry.addErrorPages(e404,e500);
	}
}

4.自定义全局错误处理器!!!!!!!!!!!
/**
 * 自定义处理异常
 * @author riverplant
 *
 */
@ControllerAdvice
public class MyGloabalExceptionHandler {
    @ExceptionHandler(value=Exception.class)//可以细化到某一个异常
    @ResponseBody
	public String errorHandler(Exception e) {
		return "global error"+e.getMessage()+"属于"+e.getClass().getName();
	}
}
-*********************tomcat**************************************************************