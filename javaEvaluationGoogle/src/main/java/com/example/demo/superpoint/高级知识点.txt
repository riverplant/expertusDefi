1.并行运算:如何排序10G个元素?
-->归并排序：
    * 将数据分为左右两半，分别归并排序，再把两个有序数据归并
     [1,3,6,7],[1,2,3,5] ->1
     [3,6,7],[1,2,3,5] ->1
     [3,6,7],[2,3,5] ->2
     [3,6,7],[3,5] ->3
     [6,7],[3,5] ->3
     ...
     *K路归并(堆：数据结构)-PriorityQueue:
      Q.push(2);
      Q.push(1);
      Q.push(3);
      Q.push(4);
      Q.pop() == 1
 归并：使用Iterable<T>接口:
           ->可以不断获取下一个元素的能力
           ->元素存储/获取方法是被抽象，与归并节点无关  
           //List<Iterable<T>> sortedData:每个节点分别排完序的数据
           ->Iterable<T> merge(List<Iterable<T>> sortedData);
      
     
->将数据拆分到每个节点上

->每个节点并行计算结果

->将结果汇总
*********************************************************************************
2.多线程(!!!!!!!!!!!!!!!!!!!!!!!!!!!!)
a.死锁分析:
  void transfer(Account from, Account to, int amount){
  synchronized(from){//同一个账户锁住,锁住账户from--->我们抢到了锁，别人在等待
  synchronized(to){//锁住账户to--->别人抢到了锁，我们在等待
          from.setAmount(from.getAmount()-amount);
          to.setAmount(to.getAmount()+amount);
  } } }
  可能死锁情况:transfer(a,b,100) 和 transfer(b,a,100) 同时进行
-->在任何地方都可以语句切换
-->尽力设想对自己最不利的情况
-------------死锁------------------------
--->互斥等待//必须有锁
       一般无法破除
--->hold and wait//拿着一个锁等另外一个锁
       最重要,一次性获取所有资源
--->循环等待
       按顺序获取资源(按账户id进行等待)

--->无法剥夺的等待
       加入超时
可以在synchronized(from)之后尝试去synchronized(to),如果失败超时就将synchronized(from)放掉
之后再尝试
*****************************线程池*******************************
线程池:预先建立好线程池
corePoolSize:初始线程数量，可能处于等待状态
maximumPoolSize:线程池中最大容许线程数量
keepAliveTime:超出corePoolSize部分线程如果等待超时会被回收
***********************java executor framwork


3.资源管理

