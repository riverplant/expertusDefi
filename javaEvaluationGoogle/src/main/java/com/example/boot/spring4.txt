1.spring4:
--> 通过注解来指定初始化方法和destroy方法
public class Dog {

	public void init() {
      System.out.println("========init=========");
	}

	public void destroy() {
		 System.out.println("========destroy=========");
	}
}

@Bean(initMethod="init",destroyMethod="destroy")
	public Dog createDog() {
		return new Dog();
	}


--> 直接通过注解指定
public class Dog {
    @PostConstruct//指定初始化
	public void init() {
      System.out.println("========init=========");
	}
    @PreDestroy//指定销毁
	public void destroy() {
		 System.out.println("========destroy=========");
	}
}	


--->通过注解指定为Component
@Component//表示该类是一个组件,用在没有明确角色
public class User {

}

@Repository//用在数据访问层
public class UserDao {

}

@Service//用在业务逻辑层
public class UserService {

}

@Controller//用在展现层Controller
public class UserController {

}
 这些注解在AnnotationConfigApplicationContext中注册后可以访问

  @Autowired//将组件注入
	private UserDao userdao;
	
User中有一个UserService -> UserService中有一个UserDao

AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MySpringConfig.class,User.class,UserDao.class);
context.getBean(Dog.class);

****************************BeanPostProcessor**********************************************
@Component
public class EchoBeanPostProcessor implements BeanPostProcessor {
	@Autowired
	private ApplicationContext applicationContext;
    /**
     * 如果返回null该对象将无法从容器中获取
     */
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("==========postProcessBeforeInitialization=============");
		if(bean instanceof MyContextAware ) {
			MyContextAware myContextAware = (MyContextAware) bean;
			myContextAware.setApplicationContext(applicationContext);
		}
		return bean;
	}
	 /**
     * 如果返回null该对象将无法从容器中获取
     */
	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("==========postProcessAfterInitialization=============");
		return bean;
	}
}

****************************BeanFactoryPostProcessor****************************************************
@Component
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {

	@Override
	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		
		beanFactory.getBeanDefinitionCount();//获得当前容器中有多少个bean
	}
}

-> 启动的时候会先执行public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor 
    该方法只执行一次，用于初始化容器
   @Override
	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		
		beanFactory.getBeanDefinitionCount();//获得当前容器中有多少个bean

	}
-->再执行public class EchoBeanPostProcessor implements BeanPostProcessor 
   用于初始化bean
**********************public interface BeanDefinitionRegistry extends AliasRegistry*****************************************
该接口用于注册一个bean到容器中
/**
 * 
 * @author riverplant
 * public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor
 */
@Component
public class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {

	@Override//该方法为继承接口BeanFactoryPostProcessor的方法，用于初始化容器
	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		System.out.println("当前容器中有:"+beanFactory.getBeanDefinitionCount()+"个bean");
	}
	@Override//该方法为新方法，用于动态的注册bean
	public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
		for(int i=0;i<10;i++) {
			BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(testBean.class);
			builder.addPropertyValue("name", "tester"+i);
			builder.addPropertyValue("id", String.valueOf(i));
			registry.registerBeanDefinition("testBean"+i,builder.getBeanDefinition() );
		}
	}

}
// 因为注册了多个同类型的bean，所以需要通过以下方法来取出
context.getBeansOfType(testBean.class).values().forEach(System.out::println);;
****************************************************************************************
BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(testBean.class);
		builder.addPropertyValue("id", "testId");
		builder.addPropertyValue("name", "testerRoot");
		context.registerBean(testBean.class, builder.getBeanDefinition());//也可以通过AnnotationConfigApplicationContext注册bean
		context.close();
