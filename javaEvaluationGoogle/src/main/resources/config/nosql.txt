1. Redis:
https://github.com/MicrosoftArchive/redis/releases
  redis.windows.conf 是redis的配置文件。

　redis-server.exe  服务器端。

   redis-cli  命令行客户端。

　redis-benchmark：Redis性能测试工具，测试Redis在你的系统及你的配置下的读写性能。

启动服务---->J:\Redis-x64-3.2.100>redis-server redis.windows.conf 
端口号:6379

Spring boot 中加入
<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
启动就会自动连接redis

#redis
spring.redis.host=localhost
spring.redis.port=6378
spring.redis.password=123456//当外网可以访问，一定要设置密码
spring.redis.database=0
spring.redis.pool.max-active=8
spring.redis.pool.max-idle=8
spring.redis.pool.max-wait=-1
spring.redis.pool.min-idle=0
spring.redis.timeout=0

********************************MongoDb******************************
https://blog.csdn.net/SHU15121856/article/details/80736092
设置db为保存数据文件夹：
输入指令:
L:\Program Files\MongoDB\Server\4.0\bin>mongod.exe --dbpath "L:\Program Files\Mo
ngoDB\Server\4.0\data\db"
访问路径:http://localhost:27017/

***************Redis*****************************************************************
NoSQL: not only sql (非关系型数据库)
-High performance 高并发读写
-Huge Storage 海量数据高效存储和访问
-High Scalability && High Availability  高可扩展和高可用性
分类:(易扩展,数据之间无关系;灵活的数据模型;大数据量，高性能；高可用):
键值(key-value)存储:可以快速查询，但是存储缺少结构化
列存储
文档数据库:MongoDb 数据结构要求不严格，但是查询效率比较低
图形数据库
************windows 启动*********************************
1. 进入 DOS窗口

2. 在进入redis的安装目录

3. 输入：redis-server --service-install redis.windows.conf --loglevel verbose ( 安装redis服务 )

4.  输入：redis-server --service-start ( 启动服务 )

5. 输入：redis-server --service-stop （停止服务）
--------------------- 
linux:
启动: ./redis-server ./redis.conf
关闭: ./redis-cli shutdown
************windows 启动*********************************
127.0.0.1:6379> ping  //测试连接
PONG
127.0.0.1:6379> set name riverplant //存入 name->riverplant
OK
127.0.0.1:6379> get name  //通过key查询
"riverplant"
127.0.0.1:6379> del name  //删除
(integer) 1
127.0.0.1:6379> keys * ////查询所有的
1) "riverCache::1"
***********高性能键值对数据库，支持的键值数据类型:***********************************

***********Jedis************************************************
vim /etc/sysconfig/iptables  //打开防火墙的设置
linux 需要打开6379端口 --dport 6379 -j ACCEPT
重启：service iptables restart
安装gcc环境  yum install gcc-c++
********数据结构**********************
->字符串类型
1.赋值:set key value
2.取值:get key  /  getset key newvalue 现获取值再修改值
3.删除:del key
4.递增值，若存在增加1，若不存在新创建0+1=1: incr num  如果对应的value不能累加，会抛出异常
5.递减值，若存在减少1，若不存在新创建0-1=-1: decr num  如果对应的value不能减少，会抛出异常
6.incrby 指定增加数量  incrby num 5
7.decrby 指定增加数量  decrby num 5
8.append 在原有的值后面追加字符串 append num 5 -->当原值不存在会直接创建
--------------------------------------------------------------------
->列表类型 HASH:String key 和String Value的map容器
1.赋值:hset myhash  username jack
      hset myhash  age 18
      hmset myhash2 username rose age 21 //存多个键值
      
2.取值:hget myhash username
       hmget myhash username age
      hgetall myhash  //获取所有属性和值
      
3.删除: hdel myhash username age //可以删除多个属性
                当删除的字段不存在，返回0
       del  myhash  //删除列表及所有的值
       
4.增加数字:  hincrby myhash age 5 

5.减少数字: hdecrby myhash age 5

6.判断  hexists myhash username  返回1表示存在，返回0表示不存在，

7.获得所有键值和值: hgetall myhash

8.得到长度: hlen myhash

9.获得所有的key: hkeys myhash

9.获得所有的value: hvals myhash
-------------------------------------------------------------------------
->有序集合类型(list)

->散列类型

->集合类型

*************应用场景：*****************************************
->缓存

->任务队列

->网站访问统计

->应用排行榜

->分布式架构中的session分离

->数据过期处理

keys 操作: 
      keys * 查询所有
      keys my? 查询my开头的数据
      del key1 key2 key3   del my1 my2 my3
    判断是否存在:1->存在  0->不存在
      exists key
      重命名key: rename keyold  keynew
      设置过期（秒）:expire key times   -> expire my1 1000
     查看剩余超时时间:ttl key  -> ttl my1 如果没有设置超时，将返回-1
     获得指定key的类型: type key   m-> type myset
*************************特性****************************
 1.多个数据库: select key   选择key数据库
 
  移动多数据库内容： move key db1 : 将key移动到db1
 
 2.事务操作: 所有命令会串行化，顺序执行
 -> multi: 开启一个事务(begin transaction),后面执行的命令都会被存到命令的队列中，直到执行exec
 
 ->exec:提交事务,当提交事务后，即使网络发生错误也将执行
 
 ->discard:回滚事务
*************************特性****************************
*********************持久化*******************************
将数据从内存中同步到硬盘上
1.RDB持久化:默认支持，在指定的时间间隔内，将内存中的数据集快照，写入磁盘
->整个Redis数据库只包含一个文件，方便备份
->数据恢复方便
--------redis.conf:------------------------
save 900 1 每900秒如果有1个key发生变化，将内存中的数据集快照，写入磁盘一次
save 300 10 每300秒如果有10个key发生变化，将内存中的数据集快照，写入磁盘一次
save 60 10000 每60秒如果有10000个key发生变化，将内存中的数据集快照，写入磁盘一次

dbfilename dump.rdb 数据保存的文件名为dump.rdb 

dir ./  文件保存路径为当前路径

--------redis.conf:------------------------
2.AOF持久化:以日志的形式记录服务器所处理的每一个操作，在redis服务器启动之初会读取该文件，从新构建数据库
每秒、每修改同步 异步完成
->数据安全
->append 写入日志
->redis -check -aof 解决数据一致性问题
->日志过大，自动切换
->包含一个日志文件记录所有操作
->配置 redis.conf
修改appendonly yes :会产生文件 appendonly.aof
同步设置:
# If unsure, use "everysec".
# appendfsync always //每修改一次，同步到硬盘,一般选择这个
appendfsync everysec //每秒同步
通过redis-cli重启redis :shutdown   ./redis-server ./redis.conf
flushall 清空数据库
每次启动，redis会根据appendonly.aof来恢复数据库

3.无持久化:Redis 只作为缓存

4.同时使用RDB和AOF

*********************持久化*******************************
********************缓存*************************
1.Caching-EhCache
<!-- caching -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-cache</artifactId>
		</dependency>
		<dependency>
			<groupId>net.sf.ehcache</groupId>
			<artifactId>ehcache</artifactId>
		</dependency>
spring: 
   cache: 
          type: ehcache
          ehcache:
                   config: classpath:config/ehcache.xml

2.Redis
flushdb:清空缓存
